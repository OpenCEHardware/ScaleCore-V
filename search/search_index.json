{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the documentation for OpenCEHardware\u2019s ScaleCore-V hardware module. This resource provides a comprehensive guide to understanding and working with the ScaleCore-V block, detailing its current capabilities, configurations, and design specifications.</p>"},{"location":"#navigation","title":"Navigation","text":"<p>To help you get the most out of this documentation, we've organized it into the following sections:</p> <ul> <li> Revisions: History of updates and changes made to the ScaleCore-V module.</li> <li> Document Conventions: Definitions, abbreviations, and standards used throughout the document.</li> <li> Introduction: Overview of the ScaleCore-V module and its key features.</li> <li> Block Diagram: Visual representation of the ScaleCore-V microarchitecture.</li> <li> Configuration: Information about module parameters, typedefs, and RTL interfaces.</li> <li> Protocols: Details on communication and operational protocols within ScaleCore-V.</li> <li> Memory Map: Structure and allocation of memory resources in the ScaleCore-V.</li> <li> Registers: Description of registers utilized in the ScaleCore-V system.</li> <li> Clock Domains: Clock structure and domain management within ScaleCore-V.</li> <li> Reset Domains: Information on reset mechanisms and domain organization.</li> <li> Interrupts: Management and handling of interrupts within the ScaleCore-V module.</li> <li> Arbitration: Methods for arbitration and shared resource access control.</li> <li> Debugging: Techniques and tools for debugging the ScaleCore-V system.</li> <li> Synthesis: Overview of design synthesis and performance results.</li> <li> Verification: Verification strategies, environments, and testbenches used with ScaleCore-V. Here's the updated Microarchitecture section with the correct sub-modules:</li> <li>Microarchitecture:<ul> <li> Fetch: Fetching and instruction retrieval mechanism.</li> <li> Decode: Instruction decoding and preparation for execution.</li> <li> Issue: Issuing instructions to relevant execution units.</li> <li> ALU: Arithmetic and logical operations performed by the ALU.</li> <li> Branch: Branch prediction and handling mechanisms.</li> <li> Foo: Additional unit for extra operations.</li> <li> Memory: Memory management and access control.</li> <li> Control-Status: Control and status register management.</li> <li> Commit: Commit process for finalized instructions.</li> <li> Skid-Buffer: Buffering for pipeline delays and instruction stalls.</li> <li> FIFO: First-In-First-Out buffer management for data handling.</li> </ul> </li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Please check the References section for more information.</p>"},{"location":"about/","title":"Authors","text":"<p>This documentation has been developed as part of a graduation project in Computer Engineering. Below are the authors responsible for the creation and development of this document:</p> <ul> <li>Alejandro Chavarr\u00eda</li> <li>Alejandro Soto</li> </ul> <p>For more information about the project, please refer to the associated GitHub organization OpenCEHardware.</p>"},{"location":"block/arbitration/","title":"Arbitration, Fairness, QoS, and Forward Progress Guarantees","text":"<p>This section addresses how the design handles arbitration between multiple traffic classes or concurrent transaction types that share resources or interfaces. It outlines the arbitration policies, fairness properties, QoS features, and forward progress guarantees [1].</p>"},{"location":"block/arbitration/#arbitration-and-fairness","title":"Arbitration and Fairness","text":"<p>Define the arbitration policy for shared resources or interfaces. Describe how multiple traffic classes or transaction types are prioritized and how fairness is ensured. If applicable, detail any configurability features that allow adjustments to the arbitration policy or QoS settings. Clearly state if any traffic classes are unfairly treated and discuss the implication [1].</p> <ul> <li>Arbitration Policy: Describe the policy used for arbitration (e.g., round-robin, priority-based).</li> <li>Fairness: Explain how fairness is maintained among traffic classes.</li> <li>Configurability: Detail any features that allow users to control arbitration or QoS.</li> </ul>"},{"location":"block/arbitration/#quality-of-service-qos","title":"Quality-of-Service (QoS)","text":"<p>Discuss the QoS mechanisms implemented in the design. Describe how the system ensures different levels of service based on traffic class or transaction type, and how these mechanisms impact system performance [1].</p> <ul> <li>QoS Features: List and describe the QoS features supported by the design.</li> <li>Impact on Performance: Explain how QoS affects the performance of the system.</li> </ul>"},{"location":"block/arbitration/#forward-progress-guarantees","title":"Forward Progress Guarantees","text":"<p>Ensure that the design provides forward progress guarantees, meaning that it avoids deadlock and livelock conditions. State any assumptions about the external system required to guarantee forward progress. Provide a high-level outline of the proof for these guarantees, and indicate if it can be formally verified [1].</p> <ul> <li>Deadlock and Livelock Prevention: Describe how the design prevents deadlock and livelock.</li> <li>Assumptions: State any assumptions needed for forward progress.</li> <li>Proof Outline: Provide a brief outline of the proof or verification approach for forward progress guarantees.</li> </ul>"},{"location":"block/clocks/","title":"Clock Domains","text":"<p>This section provides a detailed overview of the clock domains used in the design. For each clock, indicate its nominal frequency and the supported dynamic range. Include the same top-level block diagram as before, but this time annotate it to show which submodules are in each clock domain. Clock domain crossings in the data path should be explicitly drawn and encapsulated within one or more submodules. For clocks used for \"backbone\" functions spanning many submodules (e.g., a CSR bus in its own clock domain), indicate this clearly and refer to another document or appropriate section for details [1].</p>"},{"location":"block/clocks/#clock-domain-table","title":"Clock Domain Table","text":"Clock Domain Nominal Frequency Supported Dynamic Range Clock Domain 1 XX MHz YY MHz - ZZ MHz Clock Domain 2 AA MHz BB MHz - CC MHz Clock Domain 3 DD MHz EE MHz - FF MHz"},{"location":"block/clocks/#annotated-block-diagram","title":"Annotated Block Diagram","text":""},{"location":"block/configuration/","title":"Configuration","text":"<p>This section includes tables of typedefs, design parameters, and interfaces. In general, it addresses any configurability encoded into the design via RTL. Include the main parameters of the block (both private and shared), the top-level module parameters, and preprocessor macros that set global constants. Do not include parameters or macros that are derived from others. Ensure to describe any constraints and assumptions about reasonable or default values. Only explain the types that are necessary to fully define the parameters and interfaces [1].</p>"},{"location":"block/configuration/#parameters","title":"Parameters","text":"Parameter Name Type Description Default Value Range/Possible Values <code>PARAM1</code> <code>int</code> Brief description of the parameter. <code>10</code> <code>0</code> to <code>100</code> <code>PARAM2</code> <code>float</code> Brief description of the parameter. <code>0.5</code> <code>0.0</code> to <code>1.0</code> <code>PARAM3</code> <code>bool</code> Brief description of the parameter. <code>true</code> <code>true</code>, <code>false</code>"},{"location":"block/configuration/#typedefs","title":"Typedefs","text":"Typedef Name Type Description <code>typedef_name1</code> <code>struct</code> Brief description of what the typedef defines. <code>typedef_name2</code> <code>enum</code> Brief description of what the typedef defines. <code>typedef_name3</code> <code>union</code> Brief description of what the typedef defines."},{"location":"block/configuration/#interfaces","title":"Interfaces","text":"<p>This section includes a table of top-level module interfaces. Group related ports as a single interface. Show the directions and types of the ports, describe the interface's purpose, and follow common naming conventions. Mention the use of any standard protocols. Avoid excessive abbreviations. The directions, types, and names of the ports should match the RTL ports 1:1. The port directions should be from the block's perspective (as in the RTL) [1].</p>"},{"location":"block/configuration/#interface-1","title":"Interface 1","text":"Port Name Direction Type Description <code>port_name</code> Input <code>type</code> Brief description of what this port does. <code>port_name</code> Output <code>type</code> Brief description of what this port does. <code>port_name</code> In/Out <code>type</code> Brief description of what this port does. <p>Protocol Use: Mention any standard protocol used by this interface here, if applicable.</p>"},{"location":"block/configuration/#interface-2","title":"Interface 2","text":"Port Name Direction Type Description <code>port_name</code> Input <code>type</code> Brief description of what this port does. <code>port_name</code> Output <code>type</code> Brief description of what this port does. <code>port_name</code> In/Out <code>type</code> Brief description of what this port does. <p>Protocol Use: Mention any standard protocol used by this interface here, if applicable.</p>"},{"location":"block/conventions/","title":"Document Conventions","text":"<p>This section lists the conventions in terms of definitions and abbreviations that will be used throughout the document. It allows the reader to become familiar with the authors' terminology and establishes a contract with the reader. External links can also be added for further insights.</p>"},{"location":"block/conventions/#glossary","title":"Glossary","text":"<p>List of important words:</p> <ul> <li>Word: Meaning</li> <li>Word: Meaning</li> <li>Word: Meaning</li> </ul>"},{"location":"block/conventions/#abbreviations","title":"Abbreviations","text":"<p>List of important abbreviations:</p> <ul> <li>ABC: Meaning</li> <li>ABC: Meaning</li> <li>ABC: Meaning</li> </ul>"},{"location":"block/debugging/","title":"Debugging","text":"<p>This section describes the debugging mechanisms and non-mission-mode features available in the design. It includes details about debugging registers, debugging interfaces, and any special features that facilitate diagnostics and testing.</p> <p>Warning</p> <p>Testbenches do not count as debugging mechanisms!</p>"},{"location":"block/diagram/","title":"Top-Level Block Diagram","text":"<p>The top-level block diagram should indicate the block boundary and all major interfaces. Draw the top-level submodules and show how they connect internally, but avoid displaying excessive internal implementation detail. The structure of the top-level block diagram should correspond 1:1 with the contents of the top-level RTL module. Avoid \"free-floating\" logic at the top level (everything should be encapsulated in submodules) [1].</p> <p>Tip</p> <p>Markdown allows embedded HTML. With the help of diagramming software (like draw.io), you can hyperlink the diagram to different sections of the document or even external links.</p>"},{"location":"block/diagram/#example","title":"Example","text":""},{"location":"block/interrupts/","title":"Interrupts","text":"<p>This section describes the interrupts implemented in the design. For each interrupt, specify its name, the associated interrupt controller, number, priority, type (e.g., level or edge), triggering mechanism (e.g., rising/falling edge or high/low level), handling method (e.g., synchronous or asynchronous), and a brief description.</p>"},{"location":"block/interrupts/#interrupt-table","title":"Interrupt Table","text":"Interrupt Name Controller Number Priority Type Triggers Handling Description IRQ_1 Main 0 1 Edge Falling Synchronous Description of IRQ_1 IRQ_2 Aux 1 3 Level High Asynchronous Description of IRQ_2"},{"location":"block/introduction/","title":"Introduction","text":"<p>This section provides a description of the block. It briefly covers, at a high level, what the block does and presents a \"bird's-eye\" black-box view of the top-level module. It discusses the goals and non-goals of the block, how it is intended to integrate into a larger system, lists standard protocols, highlights important performance requirements, and touches on debugging features. It outlines the design methodology (coding language, internal and third-party libraries and IPs), and anything else a verification engineer should know before writing the first draft of the test plan [1]. Most of these concepts can be expressed as a list of features, as seen in an I\u00b2C-Master Core Specification [2] example.</p>"},{"location":"block/introduction/#features","title":"Features","text":"<p>In a list of sentences, this section expresses what the block is capable of and its most notable characteristics.</p>"},{"location":"block/introduction/#integration","title":"Integration","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/introduction/#performance","title":"Performance","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/introduction/#design","title":"Design","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/introduction/#debugging","title":"Debugging","text":"<ul> <li>Functionality A</li> <li>Functionality B</li> <li>Functionality C</li> </ul>"},{"location":"block/memory/","title":"Memory Map","text":"<p>This section provides a clear and organized overview of how memory is distributed in the system. It includes a table that shows memory addresses, specific regions assigned to different system components (such as ROM, RAM, peripherals, CSRs, etc.), and any relevant details about the size, access permissions, and purpose of each region. Detailed memory resource allocation facilitates the design, development, use, and debugging of the system.</p>"},{"location":"block/memory/#memory-map-table","title":"Memory Map Table","text":"Memory Address Size Region Description 0x00000000 - 0x0000FFFF 64 KB ROM (Firmware) Contains the boot code and firmware. 0x00010000 - 0x0001FFFF 64 KB RAM (Data) Stores variable data and stacks. 0x00020000 - 0x0002FFFF 64 KB Peripheral A Control and data registers of Peripheral A. 0x00030000 - 0x0003FFFF 64 KB Peripheral B Control and data registers of Peripheral B. 0x00040000 - 0x0004FFFF 64 KB RAM (Stack) Reserved space for the stack and temporary storage."},{"location":"block/protocols/","title":"Protocols","text":"<p>For all interfaces that use a standard industry protocol or an internal/proprietary protocol, list them here and link to the relevant specifications that govern those protocols. If any interfaces use custom protocols that are not defined elsewhere, define them in detail here, with one subsection per protocol. Make sure to define any protocols that involve more than one interface [1]. For custom protocols, feel free to add as much information as needed so they can be easily understood, used, and tested.</p>"},{"location":"block/protocols/#standard-protocols","title":"Standard Protocols","text":""},{"location":"block/protocols/#protocol-1","title":"Protocol 1","text":"<ul> <li>Description: Brief description of the protocol.</li> <li>Specification: Link to the protocol specification.</li> </ul>"},{"location":"block/protocols/#protocol-2","title":"Protocol 2","text":"<ul> <li>Description: Brief description of the protocol.</li> <li>Specification: Link to the protocol specification.</li> </ul>"},{"location":"block/protocols/#custom-protocols","title":"Custom Protocols","text":""},{"location":"block/protocols/#custom-protocol-1","title":"Custom Protocol 1","text":"<ul> <li>Description: Detailed description of the custom protocol.</li> <li>Involved Interfaces: List of interfaces that use this protocol.</li> <li>Data Format: Definition of the data format exchanged.</li> <li>Communication Sequence: Details about the communication sequence between interfaces.</li> </ul>"},{"location":"block/protocols/#custom-protocol-2","title":"Custom Protocol 2","text":"<ul> <li>Description: Detailed description of the custom protocol.</li> <li>Involved Interfaces: List of interfaces that use this protocol.</li> <li>Data Format: Definition of the data format exchanged.</li> <li>Communication Sequence: Details about the communication sequence between interfaces.</li> </ul>"},{"location":"block/references/","title":"References","text":"<p>Link to other related documents\u2009\u2014\u2009test plans, design information, source code location, protocol documents, chip-level specifications, etc. [1] Also link to any external papers, hardware, protocols or ideas used in the document.</p> <p>In this case the example links to the actual refernces used to elaborate this guide.</p> <p> [1] Gottscho, M. (2024, February 20). A Template for Writing a Microarchitecture Specification. Retrieved from https://markgottscho.com/posts/2024/02/20/uarch-spec-template/</p> <p> [2] Herveille, R. (2003, July 3). I\u00b2C-Master Core Specification (Rev. 0.9). OpenCores. Retrieved from https://github.com/freecores/i2c/blob/master/doc/i2c_specs.pdf</p>"},{"location":"block/registers/","title":"Registers","text":"<p>This section contains all the registers of the block, organized in tables. This includes user registers, CSRs, and other registers (e.g., debugging).</p>"},{"location":"block/registers/#user-registers","title":"User Registers","text":""},{"location":"block/registers/#user-registers-table","title":"User Registers Table","text":"Register Name Abbreviation Address Fields and Offsets Access Permissions (HW/SW) Description USER_REG_1 UR1 0x0100 FIELD1 (0-7) R/W Description of User Register 1 USER_REG_2 UR2 0x0104 FIELD1 (0-15) R Description of User Register 2"},{"location":"block/registers/#csrs-configurationstatus-registers","title":"CSRs (Configuration/Status Registers)","text":"<p>List major categories of configuration/status registers (CSRs). Define all CSRs here or link to an external document. Every CSR should define its name, address, fields and offsets, hardware and software access permissions, and a description of what each field does [1].</p> <p>Note</p> <p>Ideally, this subsection should link to CSR documentation that is auto-generated from a single-source-of-truth source code. An open-source industry tool used for this purpose is PeakRDL.</p>"},{"location":"block/registers/#csrs-table","title":"CSRs Table","text":"CSR Name Abbreviation Address Fields and Offsets Access Permissions (HW/SW) Description CSR_NAME_1 CSR1 0x0000 FIELD1 (0-7), FIELD2 (8-15) R/W Description of CSR 1 CSR_NAME_2 CSR2 0x0004 FIELD1 (0-3), FIELD2 (4-7), FIELD3 (8-15) R/W Description of CSR 2"},{"location":"block/registers/#other-registers","title":"Other Registers","text":""},{"location":"block/registers/#other-registers-table","title":"Other Registers Table","text":"Register Name Abbreviation Address Fields and Offsets Access Permissions (HW/SW) Description DEBUG_REG_1 DR1 0x0200 FIELD1 (0-7), FIELD2 (8-15) R/W Description of Debug Register 1 DEBUG_REG_2 DR2 0x0204 FIELD1 (0-3), FIELD2 (4-7), FIELD3 (8-15) R/W Description of Debug Register 2"},{"location":"block/resets/","title":"Reset Domains","text":"<p>This section provides an overview of the reset domains used in the design. For each reset, specify whether it is synchronous or asynchronous, its active level (high or low), and, if synchronous, the associated clock. Include the same top-level block diagram as before, but this time annotate it to show which submodules are in each reset domain. Reset domain crossings in the datapath should be explicitly shown and encapsulated within one or more submodules. For resets used for \"backbone\" functions that span multiple submodules (e.g., a CSR bus in its own reset domain), clearly indicate this and defer detailed information to an appropriate document or section. If the reset protocol is custom to this block, include a subsection defining the relevant procedures. Otherwise, cite other documents that provide these details [1].</p>"},{"location":"block/resets/#reset-domains-table","title":"Reset Domains Table","text":"Reset Name Synchronous/Asynchronous Active High/Low Associated Clock (if synchronous) Description RESET_1 Synchronous Active Low CLK1 Description of RESET_1 RESET_2 Asynchronous Active High N/A Description of RESET_2"},{"location":"block/resets/#annotated-block-diagram","title":"Annotated Block Diagram","text":""},{"location":"block/resets/#custom-reset-procedures","title":"Custom Reset Procedures","text":"<p>If the reset protocol is custom for this block, provide a detailed description of the procedures and mechanisms here. Otherwise, cite the relevant documentation.</p>"},{"location":"block/resets/#custom-reset-procedure","title":"Custom Reset Procedure","text":"<ol> <li>Step 1 of the procedure.</li> <li>Step 2 of the procedure.</li> <li>Step 3 of the procedure.</li> </ol>"},{"location":"block/resets/#references-to-external-documents","title":"References to External Documents","text":"<p>For standard reset protocols, refer to the following documents:</p> <ul> <li>Standard Reset Protocol Document 1</li> <li>Standard Reset Protocol Document 2</li> </ul>"},{"location":"block/revisions/","title":"Revisions","text":"<p>Continually maintain the following table of major and minor revisions of the specification, even if using a version control system like Git. Use a common version naming convention that can be shared with other related blocks. Always write dates in ISO standard form, i.e., YYYY-MM-DD [1].</p> <p>In this case, the example table corresponds to the actual revisions of this document.</p> Date (YYYY-MM-DD) Version Description of Changes Author 2024-08-07 <code>1.0.0</code> Document creation. Alejandro Chavarr\u00eda 2024-08-08 <code>1.0.1</code> Fixed diagram and navigation. Alejandro Chavarr\u00eda"},{"location":"block/synthesis/","title":"Synthesis","text":"<p>This section presents the synthesis results of the design across different FPGAs. It includes a table displaying performance, area, and other relevant parameters for each evaluated FPGA.</p>"},{"location":"block/synthesis/#synthesis-results-table","title":"Synthesis Results Table","text":"FPGA Maximum Frequency (MHz) Area (LUTs) Area (FFs) Area (BRAMs) Area (DSPs) Comments FPGA_A 200 5000 3000 10 20 Description of performance and area for FPGA_A FPGA_B 250 4800 2800 12 18 Description of performance and area for FPGA_B FPGA_C 180 5200 3100 8 22 Description of performance and area for FPGA_C"},{"location":"block/synthesis/#additional-comments-optional","title":"Additional Comments (Optional)","text":"<p>In this section, provide additional comments on the synthesis results, including observations on performance, optimization, and recommendations for future improvements or adjustments.</p>"},{"location":"block/synthesis/#observations","title":"Observations","text":"<ul> <li>Performance: Comment on the differences in maximum frequency achieved across different FPGAs and possible reasons for these differences.</li> <li>Area: Analyze how the area used varies among different FPGAs and if there are opportunities for optimization.</li> <li>Recommendations: Offer recommendations for design improvements based on the synthesis results.</li> </ul>"},{"location":"block/verification/","title":"Verification","text":"<p>This section details the types of tests applied to the block and presents relevant benchmark results.</p>"},{"location":"block/verification/#test-environment","title":"Test Environment","text":"<p>Describe the tools, simulators, or testbeds used for verification and any relevant configuration or parameters for the tests.</p>"},{"location":"block/verification/#test-environment-table","title":"Test Environment Table","text":"Tool Version Relevant Configuration Simulator X 2024.1 Configuration A, Parameter B Tool Y 3.2.1 Configuration C, Parameter D"},{"location":"block/verification/#tests","title":"Tests","text":"<p>Describe the different types of tests applied to the block, such as functional tests, regression tests, and specific verification methodologies used (e.g., simulation, formal verification, emulation).</p>"},{"location":"block/verification/#tests-table","title":"Tests Table","text":"Test Type Description Tools Used Functional Test Verification that the block meets functional specifications. Simulator X, Tool Y Regression Test Ensuring recent changes do not introduce errors in the design. Simulator Z, Test Suite W Formal Verification Rigorous mathematical verification of design properties. Tool A, Tool B"},{"location":"block/verification/#test-results","title":"Test Results","text":"<p>Show the results of the tests applied to the system, ideally in a table format.</p>"},{"location":"block/verification/#benchmarks","title":"Benchmarks","text":"<p>Include benchmark results, such as performance metrics, comparisons with expected outcomes, and block performance under different conditions.</p>"},{"location":"block/verification/#benchmarks-table","title":"Benchmarks Table","text":"Metric Value Comments Maximum Frequency 200 MHz Meets performance expectations. Latency 10 ns Within acceptable limits. Resource Usage 5000 LUTs, 3000 FFs Efficient in terms of utilized resources."},{"location":"block/verification/#benchmarks-results","title":"Benchmarks Results","text":"<p>Show the results of the benchmarks applied to the system, ideally in a table format.</p>"},{"location":"block/verification/#issues-and-resolutions","title":"Issues and Resolutions","text":"<p>Brief discussion of any issues found during verification and how they were resolved.</p>"},{"location":"block/verification/#issues-and-resolutions-table","title":"Issues and Resolutions Table","text":"Issue Description Resolution Simulation Error Results inconsistent with expectations. Adjusted simulator configuration. Timing Error Deviation in response time. Optimized design in critical path."},{"location":"block/verification/#verification-summary","title":"Verification Summary","text":"<p>Provide a brief summary of the block's results from the verification and benchmark processes.</p>"},{"location":"block/microarchitecture/alu/","title":"Arithmetic logic unit (ALU)","text":""},{"location":"block/microarchitecture/alu/#description","title":"Description","text":"<p>The <code>hsv_core_alu</code> module is a two-stage Arithmetic Logic Unit (ALU) designed as part of the execute and memory stage within the <code>hsv_core</code> architecture. Its primary function is to perform the arithmetic and logical operations of a RV32I architecture on input data from the pipeline stages and generate results to be used in subsequent stages.</p>"},{"location":"block/microarchitecture/alu/#function-and-role-in-the-system","title":"Function and Role in the System","text":"<ul> <li> <p>Sequential and Flush Control: The ALU is clocked using <code>clk_core</code> and reset with <code>rst_core_n</code>. It includes flush signals (<code>flush_req</code> and <code>flush_ack</code>) to manage pipeline flushing, allowing for the termination of in-progress operations if necessary, such as when a branch is mispredicted or an exception occurs.</p> </li> <li> <p>Data Interface: The module uses a ready-valid handshake protocol for data communication, with input (<code>valid_i</code>, <code>ready_o</code>) and output (<code>valid_o</code>, <code>ready_i</code>) signals facilitating the exchange of data between the ALU and other stages of the pipeline. The ALU receives operand data through the <code>alu_data</code> structure and outputs the results through <code>commit_data</code>.</p> </li> <li> <p>First Stage - Bitwise Operations and Setup: This stage (<code>hsv_core_alu_bitwise_setup</code>) handles the initial processing of input operands, preparing them for further arithmetic and bitwise operations. Key functions include:</p> <ul> <li>Logical Operations: Implements AND, OR, XOR, and PASS operations based on control signals (PASS = no logical operation needed).</li> <li>Shift Operations: Prepares data for left and right shifts, including sign-extended shifts and zero extensions.</li> <li>Setup for Arithmetic Operations: Prepares operands for addition, extending them to accommodate sign bits or applying negation as required.</li> </ul> </li> <li> <p>Second Stage - Shift and Add: This stage (<code>hsv_core_alu_shift_add</code>) performs the main arithmetic and shift operations:</p> <ul> <li>Addition: Implements a 33-bit addition, including handling for signed comparisons using a sign-extended representation.</li> <li>Shifting: Handles logical and arithmetic shifts, both left and right, using a unified shift logic.</li> <li>Comparison Operations: Evaluates less-than comparisons using a simple arithmetic subtraction approach, adjusting signs when necessary. This is a particular case of addittion.</li> </ul> </li> <li> <p>Piping : The results from the ALU are buffered using an <code>hs_skid_buffer</code>, which manages pipeline stalls and flush requests, the correct data flow to the next stages. The buffer is parameterized to match the data width of <code>commit_data</code>.</p> </li> <li> <p>Control Logic: A simple state control is implemented to manage flush acknowledgment (<code>flush_ack</code>), ensuring synchronization between flush requests and ALU operations.</p> </li> </ul>"},{"location":"block/microarchitecture/alu/#design-considerations-and-features","title":"Design Considerations and Features","text":"<ul> <li> <p>Pipelining: The ALU design is fully pipelined to enhance throughput, allowing different operations to be processed concurrently in separate stages. This means there can be up three instructions at the same time in the ALU (one in bitwise setup, one in shift and add and one buffered at the pipe).</p> </li> <li> <p>Shift and Add Integration: Every instruction produces both a shifted and a added result. Depending on the operation one of the outputs chosen.</p> </li> <li> <p>Support for Signed and Unsigned Operations: The module supports both signed and unsigned arithmetic and logical operations as needed for a compliant RV32I implementation.</p> </li> <li> <p>Modular Design: The ALU is designed with clear modular boundaries (<code>bitwise_setup</code> and <code>shift_add</code>), allowing for easy maintenance, testing, and potential future expansions or optimizations.</p> </li> <li> <p>Error Handling: When illegal intructions are detected by the decode stage issue routes the intruction  through ALU. This is because ALU results can be easily discarted.</p> </li> </ul>"},{"location":"block/microarchitecture/alu/#io","title":"I/O","text":""},{"location":"block/microarchitecture/alu/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>clk_core</code> Input <code>logic</code> Core clock signal for sequential operations. <code>rst_core_n</code> Input <code>logic</code> Active-low reset signal for core operations. <code>flush_req</code> Input <code>logic</code> Request signal to flush the ALU operations. <code>alu_data</code> Input <code>alu_data_t</code> Input data structure containing ALU operands and control signals. <code>valid_i</code> Input <code>logic</code> Valid signal indicating the input data is ready to be processed. <code>ready_i</code> Input <code>logic</code> Ready signal from the next stage indicating it can accept data."},{"location":"block/microarchitecture/alu/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>flush_ack</code> Output <code>logic</code> Acknowledge signal indicating flush has been processed. <code>ready_o</code> Output <code>logic</code> Ready signal indicating the ALU can accept new input data. <code>commit_data</code> Output <code>commit_data_t</code> Output data structure containing the results of ALU operations. <code>valid_o</code> Output <code>logic</code> Valid signal indicating that the output data is ready to be consumed."},{"location":"block/microarchitecture/alu/#localparams-and-structs","title":"Localparams and Structs","text":""},{"location":"block/microarchitecture/alu/#alu_data_t-struct-table","title":"<code>alu_data_t</code> Struct Table","text":"Field Name Type Description <code>illegal</code> <code>logic</code> Indicates if the instruction is illegal; set to 1 for illegal instructions and 0 for valid ALU instructions. <code>negate</code> <code>logic</code> Control signal to negate the operand(s). <code>flip_signs</code> <code>logic</code> Control signal to flip the signs of the operand(s). <code>bitwise_select</code> <code>alu_bitwise_t</code> Specifies the bitwise operation to be performed by the ALU. <code>sign_extend</code> <code>logic</code> Control signal to extend the sign of the operands. <code>is_immediate</code> <code>logic</code> Indicates whether the second operand is an immediate value. <code>compare</code> <code>logic</code> Control signal to perform a comparison operation. <code>out_select</code> <code>alu_out_t</code> Selects the output result generated by the ALU . <code>pc_relative</code> <code>logic</code> Control signal indicating that the operation is relative to the program counter (PC). <code>common</code> <code>exec_mem_common_t</code> Contains common execution and memory-related control signals shared across multiple execution units."},{"location":"block/microarchitecture/alu/#exec_mem_common_t-struct-table","title":"<code>exec_mem_common_t</code> Struct Table","text":"Field Name Type Description <code>token</code> <code>insn_token</code> Token representing the instruction id. <code>pc</code> <code>word</code> The program counter (PC) value associated with the instruction. <code>pc_increment</code> <code>word</code> Next instruction, PC+4 <code>rs1</code> <code>word</code> The value of the first source register (rs1). <code>rs2</code> <code>word</code> The value of the second source register (rs2). <code>immediate</code> <code>word</code> The immediate value associated with the instruction, if applicable."},{"location":"block/microarchitecture/alu/#alu-operation-table","title":"ALU Operation Table","text":"Mnemonic <code>add</code> <code>addi</code> <code>sub</code> <code>and</code> <code>andi</code> <code>or</code> <code>ori</code> <code>xor</code> <code>xori</code> <code>sll</code> <code>slli</code> <code>srl</code> <code>srli</code> <code>sra</code> <code>srai</code> <code>slt</code> <code>slti</code> <code>sltu</code> <code>sltiu</code> <code>lui</code> <code>auipc</code> Operation <code>q = q = a + b</code> <code>q = q = a + b</code> <code>q = q = a - b</code> <code>q = q = a &amp; b</code> <code>q = q = a &amp; b</code> <code>q = q = a | b</code> <code>q = q = a | b</code> <code>q = q = a ^ b</code> <code>q = q = a ^ b</code> <code>q = q = a &lt;&lt; b</code> <code>q = q = a &lt;&lt; b</code> <code>q = q = a &gt;&gt; b</code> <code>q = q = a &gt;&gt; b</code> <code>q = q = a &gt;&gt;&gt; b</code> <code>q = q = a &gt;&gt;&gt; b</code> <code>q = q = a &lt; b</code> <code>q = q = a &lt; b</code> <code>q = q = a &lt; b</code> <code>q = q = a &lt; b</code> <code>q = q = b</code> <code>q = q = pc + b</code> is_immediate 0 1 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 1 out_select <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_SHIFTER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> <code>ALU_OUT_ADDER</code> bitwise_select <code>x</code> <code>x</code> <code>x</code> <code>ALU_BITWISE_AND</code> <code>ALU_BITWISE_AND</code> <code>ALU_BITWISE_OR</code> <code>ALU_BITWISE_OR</code> <code>ALU_BITWISE_XOR</code> <code>ALU_BITWISE_XOR</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>ALU_BITWISE_PASS</code> <code>x</code> <code>x</code> <code>x              |</code>x<code>|</code>x<code>|</code>x` sign_extend <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 0 0 1 1 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> negate 0 0 1 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 1 1 0 0 0 0 1 1 1 1 0 0 flip_signs 0 0 0 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 1 1 0 0 0 0 compare 0 0 0 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 1 1 1 1 0 0 pc_relative 0 0 0 <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> <code>x</code> 0 0 0 0 0 1 common.rs1 a a a a a a a a a a a a a a a a a a a 0 <code>x</code> common.rs2 b <code>x</code> b b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> <code>x</code> <code>x</code> common.immediate <code>x</code> b <code>x</code> <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b <code>x</code> b b b"},{"location":"block/microarchitecture/alu/#submodule-diagram","title":"Submodule Diagram","text":"uarch-alu"},{"location":"block/microarchitecture/branch/","title":"Branching Unit","text":""},{"location":"block/microarchitecture/branch/#description","title":"Description","text":"<p>The <code>hsv_core_branch</code> module is within the core designed to handle branch operations. It determines the flow of program execution by evaluating branch conditions, computing branch targets, and managing jumps, including conditional and unconditional branches. This module interfaces with other parts of the processor pipeline, receiving branch-related inputs, processing them, and outputting results that guide the execution path of the processor. This unit also determines whether a prediction is correct or not, and sets the flush signal if mispredicted.</p> <p>Note</p> <p>This core doesn't actually predict branches, it always assumes the PC+4 as the next instruction. This means a uncoditional branch will always be mispredicted. Despite of this, our branching unit is capable of handling predictions with the <code>predicted</code> input pointer. </p>"},{"location":"block/microarchitecture/branch/#functionality","title":"Functionality","text":"<p>The module operates in multiple substages to handle the branch processing:</p> <ul> <li> <p>Branch Condition and Target Calculation (<code>hsv_core_branch_cond_target</code>):</p> <ul> <li>This submodule evaluates the conditions for conditional branches, such as equality or less-than comparisons between source operands (<code>rs1</code> and <code>rs2</code>).</li> <li>It determines whether the branch should be taken based on the condition codes and potential negations.</li> <li>If the branch is taken, it calculates the target address, which is the destination of the branch. This target address can be relative to the current program counter (<code>pc</code>) or an absolute value depending on the type of branch.</li> </ul> </li> <li> <p>Branch Jump Execution (<code>hsv_core_branch_jump</code>):</p> <ul> <li>The jump submodule uses the results from the conditional target stage to decide the final program counter (<code>pc</code>) value. If the branch is taken, it uses the target address; otherwise, it defaults to the next sequential address.</li> <li>It also checks for potential mispredictions by comparing the computed target address to the predicted address, allowing the processor to correct its path if necessary.</li> <li>An alignment check ensures that the branch target aligns with the processor's word boundaries, raising execution exceptions (traps) if a misaligned address is detected.</li> </ul> </li> <li> <p>Output Buffering (<code>hs_skid_buffer</code>):</p> <ul> <li>The results from the branch jump stage are passed through a buffering pipeline that manages flow control signals (<code>ready</code> and <code>valid</code>). This pipeline ensures that the output data is appropriately synchronized with the processor's broader execution pipeline, accommodating stalls and flush requests.</li> </ul> </li> </ul>"},{"location":"block/microarchitecture/branch/#io-table","title":"I/O Table","text":"<p>Detail the submodule's input and output signals, including their name, direction, type, and description.</p>"},{"location":"block/microarchitecture/branch/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>input_signal_1</code> Input <code>logic</code> Description of <code>input_signal_1</code> <code>input_signal_2</code> Input <code>logic</code> Description of <code>input_signal_2</code>"},{"location":"block/microarchitecture/branch/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>output_signal_1</code> Output <code>logic</code> Description of <code>output_signal_1</code> <code>output_signal_2</code> Output <code>logic</code> Description of <code>output_signal_2</code>"},{"location":"block/microarchitecture/branch/#submodule-diagram","title":"Submodule Diagram","text":"uarch-branch"},{"location":"block/microarchitecture/commit/","title":"Commit Unit","text":""},{"location":"block/microarchitecture/commit/#description","title":"Description","text":"<p>The <code>hsv_core_commit</code> module is responsible for handling the final commit stage in the CPUs processing pipeline, where results of executed operations are finalized and made visible to the rest of the system. It primary works on handling the results from the multiple parallel execution units (ALU, branch, memory, control-status, and the custom blank unit <code>foo</code>). </p>"},{"location":"block/microarchitecture/commit/#function-and-role","title":"Function and Role","text":"<p>The main function of the <code>hsv_core_commit</code> module is to receive the results from the various execution units and decide whether these results should be committed to the architectural state of the processor (e.g., registers, memory). This module also handles control signals related to traps (exceptions), interrupts, and pipeline flushes.</p> <p>Key Features: - Commit Decisions: The module evaluates if each execution unit's data is ready and valid, and then checks for any traps (errors or exceptions) associated with the data. If the data is valid and free of traps, the module generates commit signals for each respective execution unit.</p> <p>Note</p> <p>At the moment the core does not use this commit signals on their own apart from <code>mem_commit_o</code>, the other output signals where added for symmetry and future uses, if necesarry.</p> <ul> <li> <p>Token Mechanism: A token-based system is employed to synchronize the commit stage with the execution units. Tokens help ensure that data from the execution units is processed in the correct order.</p> </li> <li> <p>Writeback Control: This module generates signals for writing back data to the register file, including the register address, the data to be written, and whether the write should occur. </p> </li> <li> <p>Trap Handling: It manages trap signals, which occur when there are exceptions or errors in the execution units, and generates appropriate control signals such as <code>ctrl_trap</code>, <code>ctrl_trap_cause</code>, and <code>ctrl_trap_value</code>. It also manages the next program counter (<code>ctrl_next_pc</code>) when a trap or jump occurs.</p> </li> <li> <p>Commit Mask: A commit mask is generated for tracking which registers are affected by the commit process, ensuring issue can clear out any RAW stalls once the instruction has been commited.</p> </li> </ul>"},{"location":"block/microarchitecture/commit/#design-considerations","title":"Design Considerations","text":"<ul> <li> <p>Synchronization with Execution Units: Each execution unit provides a valid signal (<code>alu_valid_i</code>, <code>branch_valid_i</code>, etc.) and a ready signal from the commit stage (<code>alu_ready_o</code>, <code>branch_ready_o</code>, etc.). The synchronization is handled via a token mechanism that matches tokens from the execution units to the commit stage, ensuring correct data flow.</p> </li> <li> <p>Trap and Exception Management: The module handles traps by blocking the commit process for data with associated traps, thus preventing erroneous state updates.</p> </li> <li> <p>Performance and Scalability: The use of parallel commit lines and token management helps maintain high performance by enabling parallel processing of results from multiple execution units.</p> </li> <li> <p>Flush Mechanism: The <code>flush_req</code> and <code>flush_ack</code> signals allow the module to control when to reset the pipeline.</p> </li> <li> <p>Control Signals: The module manages several critical control signals that dictate the overall flow of execution and responses to exceptional events within the core, like interrupts or pipeline flushes.</p> </li> </ul>"},{"location":"block/microarchitecture/commit/#io-table","title":"I/O Table","text":"<p>Detail the submodule's input and output signals, including their name, direction, type, and description.</p>"},{"location":"block/microarchitecture/commit/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>input_signal_1</code> Input <code>logic</code> Description of <code>input_signal_1</code> <code>input_signal_2</code> Input <code>logic</code> Description of <code>input_signal_2</code>"},{"location":"block/microarchitecture/commit/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>output_signal_1</code> Output <code>logic</code> Description of <code>output_signal_1</code> <code>output_signal_2</code> Output <code>logic</code> Description of <code>output_signal_2</code>"},{"location":"block/microarchitecture/commit/#submodule-diagram","title":"Submodule Diagram","text":"<p>Include a diagram of the submodule here, showing its inputs, outputs, and how they are connected internally. Ensure the diagram is clear and properly labeled to facilitate understanding.</p>"},{"location":"block/microarchitecture/issue/","title":"Issue Unit","text":""},{"location":"block/microarchitecture/issue/#description","title":"Description","text":"<p>The <code>hsv_core_issue</code> module represents the stage in the processor pipeline where instructions are prepared and distributed one of the various execution units. It acts as a bridge between the instruction fetch and decode stages and the execution and memory stage, ensuring that instructions are correctly scheduled, hazards are managed, and data dependencies are resolved before sending instructions to the appropriate execution units. Below is an explanation of the pipeline stages within the <code>hsv_core_issue</code> module, including their functions, roles, and design considerations:</p>"},{"location":"block/microarchitecture/issue/#module-overview","title":"Module Overview","text":"<ul> <li> <p>Hazard Mask Generation Stage:</p> <ul> <li>This stage identifies potential hazards by examining the register usage of the incoming instruction. It generates a hazard mask that marks registers currently in use by ongoing instructions, preventing conflicts and incorrect data usage.</li> <li>It checks for read-after-write (RAW) hazards by comparing the registers being read in the current instruction with those being written by in-flight instructions.</li> <li>The output of this stage is a register mask (<code>rd_mask</code>) and a valid signal (<code>valid_o</code>).</li> </ul> </li> <li> <p>Fork Stage:</p> <ul> <li>The fork stage enroutes instruction data to the appropriate execution unit (ALU, branch, control-status, and memory) based on the instruction type.</li> <li>It manages stalls across different units by selectively stalling data flow to prevent overflow or resource conflicts. Each execution unit can independently stall if it is not ready to accept new data.</li> <li>This stage must manage the timing and synchronization of data between multiple execution units, accounting for variations in ready signals and stalls from each unit.</li> </ul> </li> <li> <p>Buffering Stage (Skid Buffers):</p> <ul> <li>The buffering stage uses skid buffers to temporarily hold data for each execution unit (ALU, branch, control-status, and memory). This buffering smooths out the flow of data and allows the system to handle back-pressure when units are not ready to receive data immediately.</li> <li>The skid buffers manage ready and valid signals between the fork stage and execution units, allowing each unit to consume data at its own pace without stalling the entire issue pipeline.</li> </ul> </li> </ul>"},{"location":"block/microarchitecture/issue/#design-features-and-considerations","title":"Design Features and Considerations","text":"<ul> <li>Stall Management: The issue pipeline uses a combination of stall signals (<code>alu_stall</code>, <code>branch_stall</code>, <code>ctrl_status_stall</code>, <code>mem_stall</code>) to control the flow of data through the pipeline. The overall pipeline stall (<code>stall</code>) is determined by aggregating the stalls from individual units.</li> <li>Flush Handling: The pipeline includes flush logic to clear in-flight instructions when incorrect paths are detected or when a pipeline reset is necessary. The <code>flush_req</code> and <code>flush_ack</code> signals coordinate this action.</li> <li>Data Path Management: Registers and data paths are managed to ensure that the correct data is available to each execution unit when needed. This includes handling special cases such as register x0 (always zero).</li> </ul>"},{"location":"block/microarchitecture/issue/#io-table","title":"I/O Table","text":"<p>Detail the submodule's input and output signals, including their name, direction, type, and description.</p>"},{"location":"block/microarchitecture/issue/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>input_signal_1</code> Input <code>logic</code> Description of <code>input_signal_1</code> <code>input_signal_2</code> Input <code>logic</code> Description of <code>input_signal_2</code>"},{"location":"block/microarchitecture/issue/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>output_signal_1</code> Output <code>logic</code> Description of <code>output_signal_1</code> <code>output_signal_2</code> Output <code>logic</code> Description of <code>output_signal_2</code>"},{"location":"block/microarchitecture/issue/#submodule-diagram","title":"Submodule Diagram","text":"<p>Include a diagram of the submodule here, showing its inputs, outputs, and how they are connected internally. Ensure the diagram is clear and properly labeled to facilitate understanding.</p>"},{"location":"block/microarchitecture/memory/","title":"Memory Unit","text":""},{"location":"block/microarchitecture/memory/#description","title":"Description","text":"<p>The <code>hsv_core_mem</code> module is memory interface unit designed to handle memory transactions in the processor core. It interacts with memory through an AXI interface and manages both read and write requests with control over timing and sequencing to ensure correct execution and memory consistency. The unit is structured with multiple internal modules, each serving a specific role to facilitate the overall functionality and effiency of the memory unit.</p>"},{"location":"block/microarchitecture/memory/#module-overview","title":"Module Overview","text":"<ul> <li> <p>hsv_core_mem_address:</p> <ul> <li>This module is responsible for generating memory access requests. It processes incoming memory data and validates the requests based on the input signals. The <code>address_stage</code> module generates transactions for read and write operations and sends these transactions to the request and response pipelines.</li> </ul> </li> <li> <p>Request and Response FIFOs:</p> <ul> <li>These FIFO modules are used to buffer transactions between the various stages of the memory interface. They help in managing data flow and preventing stalls in the pipeline by providing temporary storage for read and write requests (<code>request_fifo</code>) and responses (<code>response_fifo</code>). The FIFO depth is configurable via a parameter (<code>FIFO_DEPTH</code>), allowing tuning for different workloads and system requirements.</li> </ul> </li> <li> <p>hsv_core_mem_request:</p> <ul> <li>This module handles the dispatch of memory requests to the AXI interface (<code>dmem</code>). It tracks pending read and write operations using internal counters (<code>pending_reads</code>, <code>pending_writes</code>, <code>write_balance</code>) to ensure proper ordering and management of transactions. This module ensures that reads and writes do not interfere with each other and that write operations are properly serialized when required. It also manages the stalling conditions for the AXI write and read channels.</li> </ul> </li> <li> <p>hsv_core_mem_response:</p> <ul> <li>The <code>hsv_core_mem_response</code> module manages the reception of responses from the memory system. It processes read and write completions, updates the status counters (<code>pending_reads</code>, <code>pending_writes</code>, <code>write_balance</code>), and handles error conditions such as unaligned addresses or memory access faults. This module also prepares the data to be committed back to the processor core, ensuring that memory operations are completed in the correct order and without errors.</li> </ul> </li> <li> <p>hsv_core_mem_counter (Pending Reads, Pending Writes, Write Balance Counters):</p> <ul> <li>These counter modules track the number of outstanding read and write transactions as well as the balance of committed but unexecuted writes. The <code>pending_reads</code> counter increments for each read request and decrements upon completion, while <code>pending_writes</code> behaves similarly for write requests. The <code>write_balance</code> counter helps in managing write serialization by keeping track of writes that have been committed but not yet executed.</li> </ul> </li> <li> <p>hs_skid_buffer (Commit Data Buffer):</p> <ul> <li>This buffer module connects the output of the <code>response_stage</code> to the processor core's commit interface. It temporarily holds data until the core is ready to receive it, managing backpressure and ensuring smooth data transfer. The skid buffer prevents data loss in case of stalling conditions at the commit interface.</li> </ul> </li> </ul>"},{"location":"block/microarchitecture/memory/#key-functionalities","title":"Key Functionalities","text":"<ul> <li>Transaction Management: The memory unit uses FIFOs and counters to manage the flow of memory transactions, ensuring that operations are executed in the correct order and that pipeline stalls are minimized.</li> <li>Flush Control: The memory unit can handle flush requests, which are used to clear pending transactions and reset the unit\u2019s state. A flush can only proceed when all counters (<code>pending_reads</code>, <code>pending_writes</code>, <code>write_balance</code>) are zero, ensuring that no transactions are left in an incomplete state.</li> <li>Stall and Backpressure Handling: The unit is designed to handle backpressure from the memory system gracefully, using FIFOs to buffer transactions and controlling flow with stall signals.</li> <li>Error Handling: The <code>response_stage</code> module includes mechanisms for detecting and managing errors such as non existent or misaligned addresses.</li> </ul>"},{"location":"block/microarchitecture/memory/#io-table","title":"I/O Table","text":"<p>Detail the submodule's input and output signals, including their name, direction, type, and description.</p>"},{"location":"block/microarchitecture/memory/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>input_signal_1</code> Input <code>logic</code> Description of <code>input_signal_1</code> <code>input_signal_2</code> Input <code>logic</code> Description of <code>input_signal_2</code>"},{"location":"block/microarchitecture/memory/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>output_signal_1</code> Output <code>logic</code> Description of <code>output_signal_1</code> <code>output_signal_2</code> Output <code>logic</code> Description of <code>output_signal_2</code>"},{"location":"block/microarchitecture/memory/#submodule-diagram","title":"Submodule Diagram","text":"uarch-memory"},{"location":"block/microarchitecture/sub2/","title":"Submodule 2","text":""},{"location":"block/microarchitecture/sub2/#description","title":"Description","text":"<p>Provide a description of the submodule here. Explain its function, role within the larger system, and any important design considerations or features.</p>"},{"location":"block/microarchitecture/sub2/#io-table","title":"I/O Table","text":"<p>Detail the submodule's input and output signals, including their name, direction, type, and description.</p>"},{"location":"block/microarchitecture/sub2/#input-table","title":"Input Table","text":"Input Name Direction Type Description <code>input_signal_1</code> Input <code>logic</code> Description of <code>input_signal_1</code> <code>input_signal_2</code> Input <code>logic</code> Description of <code>input_signal_2</code>"},{"location":"block/microarchitecture/sub2/#output-table","title":"Output Table","text":"Output Name Direction Type Description <code>output_signal_1</code> Output <code>logic</code> Description of <code>output_signal_1</code> <code>output_signal_2</code> Output <code>logic</code> Description of <code>output_signal_2</code>"},{"location":"block/microarchitecture/sub2/#submodule-diagram","title":"Submodule Diagram","text":"<p>Include a diagram of the submodule here, showing its inputs, outputs, and how they are connected internally. Ensure the diagram is clear and properly labeled to facilitate understanding.</p>"},{"location":"block/microarchitecture/sub2/#systemverilog-implementation","title":"SystemVerilog Implementation","text":"<p>Include a brief description of the SystemVerilog code for the submodule, highlighting key parts of the implementation if needed for a clearer understanding.</p> <p>Tip</p> <p>Mkdocs allows a plethora of highlighting and cues for better code documentation. Read more.</p>"},{"location":"block/microarchitecture/sub2/#example-code","title":"Example Code","text":"<pre><code>module Submodule (\n    input  logic input_signal_1,\n    input  logic input_signal_2,\n    output logic output_signal_1,\n    output logic output_signal_2\n);\n  // Description of the submodule's functionality\n\n  // Module logic\n  always_ff @(posedge clk) begin\n    // Implementation of the functionality\n  end\nendmodule\n</code></pre>"}]}